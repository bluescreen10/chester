package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
)

const (
	packageName = "main"
	fileName    = "const.go"
)

var rays []string = []string{"North", "East", "South", "West", "NorthEast", "SouthEast", "SouthWest", "NorthWest"}

const (
	North int8 = iota
	East
	South
	West
	NorthEast
	SouthEast
	SouthWest
	NorthWest
)

func main() {
	buf := new(bytes.Buffer)

	generatePreamble(buf)
	generateRays(buf)
	generateKnightMoves(buf)
	generateKingMoves(buf)
	generateSquaresBetween(buf)
	generateLineFromTo(buf)
	generateFileRankMasks(buf)
	generateSquares(buf)

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("error formatting source: %v\n%s", err, buf.String())
	}

	if err := os.WriteFile(fileName, src, 0o644); err != nil {
		log.Fatalf("error writing file: %v", err)
	}
}

func generatePreamble(w io.Writer) {
	fmt.Fprintf(w, "// Code generated by internal/cmd/const.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", packageName)
}

func generateRays(w io.Writer) {

	// direction type
	fmt.Fprintf(w, "type direction int8\n\n")
	fmt.Fprintf(w, "const (\n")
	for i, d := range rays {
		if i == 0 {
			fmt.Fprintf(w, "\t%s direction = iota\n", d)
		} else {
			fmt.Fprintf(w, "\t%s\n", d)
		}
	}
	fmt.Fprintf(w, ")\n\n")

	// rays
	r := calculateRays()

	fmt.Fprintf(w, "var rays [direction(8)][Square(64)]BitBoard = [direction(8)][Square(64)]BitBoard{\n")
	for i := range 8 {
		fmt.Fprintf(w, "\t{\n")
		for j := range 64 {
			fmt.Fprintf(w, "\t\t%d,\n", r[i][j])
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func calculateRays() [8][64]uint64 {
	rays := [8][64]uint64{}

	for i := range 64 {
		r, f := sqaureToRankAndFile(i)

		for j := 1; j < 8; j++ {
			if r-j >= 0 && f-j >= 0 {
				rays[SouthWest][i] |= 1 << uint8((7-r+j)*8+f-j)
			}
			if r-j >= 0 && f+j < 8 {
				rays[SouthEast][i] |= 1 << uint8((7-r+j)*8+f+j)
			}
			if r+j < 8 && f-j >= 0 {
				rays[NorthWest][i] |= 1 << uint8((7-r-j)*8+f-j)
			}
			if r+j < 8 && f+j < 8 {
				rays[NorthEast][i] |= 1 << uint8((7-r-j)*8+f+j)
			}
		}
	}

	for i := range 64 {
		r, f := sqaureToRankAndFile(i)

		for j := 1; j < 8; j++ {
			if r-j >= 0 {
				rays[South][i] |= 1 << uint8((7-r+j)*8+f)
			}
			if r+j < 8 {
				rays[North][i] |= 1 << uint8((7-r-j)*8+f)
			}
			if f-j >= 0 {
				rays[West][i] |= 1 << uint8((7-r)*8+f-j)
			}
			if f+j < 8 {
				rays[East][i] |= 1 << uint8((7-r)*8+f+j)
			}
		}
	}

	return rays
}

func generateKnightMoves(w io.Writer) {
	knightMoves := calculateKnightMoves()

	fmt.Fprintf(w, "var knightMoves [Square(64)]BitBoard = [Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t%d,\n", knightMoves[i])
	}
	fmt.Fprintf(w, "}\n")
}

func calculateKnightMoves() [64]uint64 {
	knightMoves := [64]uint64{}

	for i := range 64 {
		rank, file := sqaureToRankAndFile(i)
		moves := [][]int{{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}}

		for _, offsets := range moves {
			targetRank, targetFile := rank+offsets[0], file+offsets[1]
			if targetRank < 0 || targetRank > 7 || targetFile < 0 || targetFile > 7 {
				continue
			}

			knightMoves[i] |= 1 << uint8((7-targetRank)*8+targetFile)
		}
	}
	return knightMoves
}

func generateKingMoves(w io.Writer) {
	kingMoves := calculateKingMoves()

	fmt.Fprintf(w, "var kingMoves [Square(64)]BitBoard = [Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t%d,\n", kingMoves[i])
	}
	fmt.Fprintf(w, "}\n")
}

func calculateKingMoves() [64]uint64 {
	kingMoves := [64]uint64{}

	for i := range 64 {
		rank, file := sqaureToRankAndFile(i)
		moves := [][]int{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}

		for _, offsets := range moves {
			targetRank, targetFile := rank+offsets[0], file+offsets[1]
			if targetRank < 0 || targetRank > 7 || targetFile < 0 || targetFile > 7 {
				continue
			}

			kingMoves[i] |= 1 << uint8((7-targetRank)*8+targetFile)
		}
	}

	return kingMoves
}

func generateSquaresBetween(w io.Writer) {
	squaresBetween := calculateSquaresBetween()

	fmt.Fprintf(w, "var squaresBetween [Square(64)][Square(64)]BitBoard = [Square(64)][Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t{\n")
		for j := range 64 {
			fmt.Fprintf(w, "\t\t%d,\n", squaresBetween[i][j])
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func calculateSquaresBetween() [64][64]uint64 {
	squaresBetween := [64][64]uint64{}
	rays := calculateRays()

	for i := range 64 {
		for j := range 64 {
			if i == j {
				continue
			}

			r1, f1 := sqaureToRankAndFile(i)
			r2, f2 := sqaureToRankAndFile(j)

			if r1 == r2 || f1 == f2 {
				squaresBetween[i][j] =
					(rays[North][i] & rays[South][j]) |
						(rays[South][i] & rays[North][j]) |
						(rays[East][i] & rays[West][j]) |
						(rays[West][i] & rays[East][j])
			} else if abs(r1-r2) == abs(f1-f2) {
				squaresBetween[i][j] =
					(rays[NorthEast][i] & rays[SouthWest][j]) |
						(rays[SouthWest][i] & rays[NorthEast][j]) |
						(rays[NorthWest][i] & rays[SouthEast][j]) |
						(rays[SouthEast][i] & rays[NorthWest][j])
			}
		}
	}

	return squaresBetween
}

func generateLineFromTo(w io.Writer) {
	linesFromTo := calculateLineFromTo()
	fmt.Fprintf(w, "var lineFromTo [Square(64)][Square(64)]BitBoard = [Square(64)][Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t{\n")
		for j := range 64 {
			fmt.Fprintf(w, "\t\t%d,\n", linesFromTo[i][j])
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func calculateLineFromTo() [64][64]uint64 {
	lineFromTo := [64][64]uint64{}
	rays := calculateRays()

	for i := range 64 {
		for j := range 64 {
			if i == j {
				continue
			}

			r1, f1 := sqaureToRankAndFile(i)
			r2, f2 := sqaureToRankAndFile(j)

			if r1 == r2 {
				if f1 < f2 {
					lineFromTo[i][j] = rays[East][i]
				} else {
					lineFromTo[i][j] = rays[West][i]
				}
			} else if f1 == f2 {
				if r1 < r2 {
					lineFromTo[i][j] = rays[North][i]
				} else {
					lineFromTo[i][j] = rays[South][i]
				}
			} else if abs(r1-r2) == abs(f1-f2) {
				if r1 < r2 && f1 < f2 {
					lineFromTo[i][j] = rays[NorthEast][i]
				} else if r1 < r2 && f1 > f2 {
					lineFromTo[i][j] = rays[NorthWest][i]
				} else if r1 > r2 && f1 < f2 {
					lineFromTo[i][j] = rays[SouthEast][i]
				} else {
					lineFromTo[i][j] = rays[SouthWest][i]
				}
			}
		}
	}
	return lineFromTo
}

func generateFileRankMasks(w io.Writer) {
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "\tFile_A BitBoard = 0x0101010101010101\n")
	fmt.Fprintf(w, "\tFile_B BitBoard = 0x0202020202020202\n")
	fmt.Fprintf(w, "\tFile_C BitBoard = 0x0404040404040404\n")
	fmt.Fprintf(w, "\tFile_D BitBoard = 0x0808080808080808\n")
	fmt.Fprintf(w, "\tFile_E BitBoard = 0x1010101010101010\n")
	fmt.Fprintf(w, "\tFile_F BitBoard = 0x2020202020202020\n")
	fmt.Fprintf(w, "\tFile_G BitBoard = 0x4040404040404040\n")
	fmt.Fprintf(w, "\tFile_H BitBoard = 0x8080808080808080\n\n")

	fmt.Fprintf(w, "\tRank_1 BitBoard = 0xFF00000000000000\n")
	fmt.Fprintf(w, "\tRank_2 BitBoard = 0x00FF000000000000\n")
	fmt.Fprintf(w, "\tRank_3 BitBoard = 0x0000FF0000000000\n")
	fmt.Fprintf(w, "\tRank_4 BitBoard = 0x000000FF00000000\n")
	fmt.Fprintf(w, "\tRank_5 BitBoard = 0x00000000FF000000\n")
	fmt.Fprintf(w, "\tRank_6 BitBoard = 0x0000000000FF0000\n")
	fmt.Fprintf(w, "\tRank_7 BitBoard = 0x000000000000FF00\n")
	fmt.Fprintf(w, "\tRank_8 BitBoard = 0x00000000000000FF\n\n")

	fmt.Fprintf(w, "\tFile_Not_A BitBoard = ^File_A\n")
	fmt.Fprintf(w, "\tFile_Not_H BitBoard = ^File_H\n\n")

	fmt.Fprintf(w, "\tEmptyBoard BitBoard = 0\n")
	fmt.Fprintf(w, "\tFullBoard  BitBoard = 0xFFFFFFFFFFFFFFFF\n")
	fmt.Fprintf(w, ")\n")
}

func generateSquares(w io.Writer) {
	fmt.Fprintf(w, "const (\n")
	for i := range 64 {
		r, f := sqaureToRankAndFile(i)
		if i == 0 {
			fmt.Fprintf(w, "\tSQ_%c%c Square = iota\n", 'A'+f, '1'+r)
		} else {
			fmt.Fprintf(w, "\tSQ_%c%c\n", 'A'+f, '1'+r)
		}
	}
	fmt.Fprintf(w, "\t SQ_NULL\n")
	fmt.Fprintf(w, ")\n")
}

func sqaureToRankAndFile(i int) (int, int) {
	return 7 - i/8, i % 8
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
