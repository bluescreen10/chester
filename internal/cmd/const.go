package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"math/bits"
	"math/rand"
	"os"
)

const (
	packageName = "main"
	fileName    = "const.go"
)

var rays []string = []string{"North", "East", "South", "West", "NorthEast", "SouthEast", "SouthWest", "NorthWest"}

const (
	North int8 = iota
	East
	South
	West
	NorthEast
	SouthEast
	SouthWest
	NorthWest
)

const (
	Rank_1 uint64 = 0xFF00000000000000
	Rank_8 uint64 = 0x00000000000000FF
	File_A uint64 = 0x0101010101010101
	File_H uint64 = 0x8080808080808080
)

func main() {
	buf := new(bytes.Buffer)

	generatePreamble(buf)
	generateRays(buf)
	generateKnightMoves(buf)
	generateKingMoves(buf)
	//generateSquaresBetween(buf)
	generateLineFromTo(buf)
	generateFileRankMasks(buf)
	generateSquares(buf)
	//genEnPassantNeighbours(buf)
	genMagicnumbers(buf)

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("error formatting source: %v\n%s", err, buf.String())
	}

	if err := os.WriteFile(fileName, src, 0o644); err != nil {
		log.Fatalf("error writing file: %v", err)
	}
}

func generatePreamble(w io.Writer) {
	fmt.Fprintf(w, "// Code generated by internal/cmd/const.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", packageName)
}

func generateRays(w io.Writer) {

	// direction type
	fmt.Fprintf(w, "type direction int8\n\n")
	fmt.Fprintf(w, "const (\n")
	for i, d := range rays {
		if i == 0 {
			fmt.Fprintf(w, "\t%s direction = iota\n", d)
		} else {
			fmt.Fprintf(w, "\t%s\n", d)
		}
	}
	fmt.Fprintf(w, ")\n\n")

	// rays
	r := calculateRays()

	fmt.Fprintf(w, "var rays [direction(8)][Square(64)]BitBoard = [direction(8)][Square(64)]BitBoard{\n")
	for i := range 8 {
		fmt.Fprintf(w, "\t{\n")
		for j := range 64 {
			fmt.Fprintf(w, "\t\t%d,\n", r[i][j])
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func calculateRays() [8][64]uint64 {
	rays := [8][64]uint64{}

	for i := range 64 {
		r, f := sqaureToRankAndFile(i)

		for j := 1; j < 8; j++ {
			if r-j >= 0 && f-j >= 0 {
				rays[SouthWest][i] |= 1 << uint8((7-r+j)*8+f-j)
			}
			if r-j >= 0 && f+j < 8 {
				rays[SouthEast][i] |= 1 << uint8((7-r+j)*8+f+j)
			}
			if r+j < 8 && f-j >= 0 {
				rays[NorthWest][i] |= 1 << uint8((7-r-j)*8+f-j)
			}
			if r+j < 8 && f+j < 8 {
				rays[NorthEast][i] |= 1 << uint8((7-r-j)*8+f+j)
			}
		}
	}

	for i := range 64 {
		r, f := sqaureToRankAndFile(i)

		for j := 1; j < 8; j++ {
			if r-j >= 0 {
				rays[South][i] |= 1 << uint8((7-r+j)*8+f)
			}
			if r+j < 8 {
				rays[North][i] |= 1 << uint8((7-r-j)*8+f)
			}
			if f-j >= 0 {
				rays[West][i] |= 1 << uint8((7-r)*8+f-j)
			}
			if f+j < 8 {
				rays[East][i] |= 1 << uint8((7-r)*8+f+j)
			}
		}
	}

	return rays
}

func generateKnightMoves(w io.Writer) {
	knightMoves := calculateKnightMoves()

	fmt.Fprintf(w, "var knightMoves [Square(64)]BitBoard = [Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t%d,\n", knightMoves[i])
	}
	fmt.Fprintf(w, "}\n")
}

func calculateKnightMoves() [64]uint64 {
	knightMoves := [64]uint64{}

	for i := range 64 {
		rank, file := sqaureToRankAndFile(i)
		moves := [][]int{{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}}

		for _, offsets := range moves {
			targetRank, targetFile := rank+offsets[0], file+offsets[1]
			if targetRank < 0 || targetRank > 7 || targetFile < 0 || targetFile > 7 {
				continue
			}

			knightMoves[i] |= 1 << uint8((7-targetRank)*8+targetFile)
		}
	}
	return knightMoves
}

func generateKingMoves(w io.Writer) {
	kingMoves := calculateKingMoves()

	fmt.Fprintf(w, "var kingMoves [Square(64)]BitBoard = [Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t%d,\n", kingMoves[i])
	}
	fmt.Fprintf(w, "}\n")
}

func calculateKingMoves() [64]uint64 {
	kingMoves := [64]uint64{}

	for i := range 64 {
		rank, file := sqaureToRankAndFile(i)
		moves := [][]int{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}

		for _, offsets := range moves {
			targetRank, targetFile := rank+offsets[0], file+offsets[1]
			if targetRank < 0 || targetRank > 7 || targetFile < 0 || targetFile > 7 {
				continue
			}

			kingMoves[i] |= 1 << uint8((7-targetRank)*8+targetFile)
		}
	}

	return kingMoves
}

// func generateSquaresBetween(w io.Writer) {
// 	squaresBetween := calculateSquaresBetween()

// 	fmt.Fprintf(w, "var squaresBetween [Square(64)][Square(64)]BitBoard = [Square(64)][Square(64)]BitBoard{\n")
// 	for i := range 64 {
// 		fmt.Fprintf(w, "\t{\n")
// 		for j := range 64 {
// 			fmt.Fprintf(w, "\t\t%d,\n", squaresBetween[i][j])
// 		}
// 		fmt.Fprintf(w, "\t},\n")
// 	}
// 	fmt.Fprintf(w, "}\n")
// }

// func calculateSquaresBetween() [64][64]uint64 {
// 	squaresBetween := [64][64]uint64{}
// 	rays := calculateRays()

// 	for i := range 64 {
// 		for j := range 64 {
// 			if i == j {
// 				continue
// 			}

// 			r1, f1 := sqaureToRankAndFile(i)
// 			r2, f2 := sqaureToRankAndFile(j)

// 			if r1 == r2 || f1 == f2 {
// 				squaresBetween[i][j] =
// 					(rays[North][i] & rays[South][j]) |
// 						(rays[South][i] & rays[North][j]) |
// 						(rays[East][i] & rays[West][j]) |
// 						(rays[West][i] & rays[East][j])
// 			} else if abs(r1-r2) == abs(f1-f2) {
// 				squaresBetween[i][j] =
// 					(rays[NorthEast][i] & rays[SouthWest][j]) |
// 						(rays[SouthWest][i] & rays[NorthEast][j]) |
// 						(rays[NorthWest][i] & rays[SouthEast][j]) |
// 						(rays[SouthEast][i] & rays[NorthWest][j])
// 			}
// 		}
// 	}

// 	return squaresBetween
// }

func generateLineFromTo(w io.Writer) {
	linesFromTo := calculateLineFromTo()
	fmt.Fprintf(w, "var lineFromTo [Square(64)][Square(64)]BitBoard = [Square(64)][Square(64)]BitBoard{\n")
	for i := range 64 {
		fmt.Fprintf(w, "\t{\n")
		for j := range 64 {
			fmt.Fprintf(w, "\t\t%d,\n", linesFromTo[i][j])
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func calculateLineFromTo() [64][64]uint64 {
	lineFromTo := [64][64]uint64{}
	rays := calculateRays()

	for i := range 64 {
		for j := range 64 {
			if i == j {
				continue
			}

			r1, f1 := sqaureToRankAndFile(i)
			r2, f2 := sqaureToRankAndFile(j)

			if r1 == r2 {
				if f1 < f2 {
					lineFromTo[i][j] = rays[East][i] &^ rays[East][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)

				} else {
					lineFromTo[i][j] = rays[West][i] &^ rays[West][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				}
			} else if f1 == f2 {
				if r1 < r2 {
					lineFromTo[i][j] = rays[North][i] &^ rays[North][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				} else {
					lineFromTo[i][j] = rays[South][i] &^ rays[South][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				}
			} else if abs(r1-r2) == abs(f1-f2) {
				if r1 < r2 && f1 < f2 {
					lineFromTo[i][j] = rays[NorthEast][i] &^ rays[NorthEast][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				} else if r1 < r2 && f1 > f2 {
					lineFromTo[i][j] = rays[NorthWest][i] &^ rays[NorthWest][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				} else if r1 > r2 && f1 < f2 {
					lineFromTo[i][j] = rays[SouthEast][i] &^ rays[SouthEast][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				} else {
					lineFromTo[i][j] = rays[SouthWest][i] &^ rays[SouthWest][j]
					lineFromTo[i][j] |= (1 << j)
					//lineFromTo[i][j] |= (1 << i)
				}
			}
		}
	}
	return lineFromTo
}

func generateFileRankMasks(w io.Writer) {
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "\tFile_A BitBoard = 0x0101010101010101\n")
	fmt.Fprintf(w, "\tFile_B BitBoard = 0x0202020202020202\n")
	fmt.Fprintf(w, "\tFile_C BitBoard = 0x0404040404040404\n")
	fmt.Fprintf(w, "\tFile_D BitBoard = 0x0808080808080808\n")
	fmt.Fprintf(w, "\tFile_E BitBoard = 0x1010101010101010\n")
	fmt.Fprintf(w, "\tFile_F BitBoard = 0x2020202020202020\n")
	fmt.Fprintf(w, "\tFile_G BitBoard = 0x4040404040404040\n")
	fmt.Fprintf(w, "\tFile_H BitBoard = 0x8080808080808080\n\n")

	fmt.Fprintf(w, "\tRank_1 BitBoard = 0xFF00000000000000\n")
	fmt.Fprintf(w, "\tRank_2 BitBoard = 0x00FF000000000000\n")
	fmt.Fprintf(w, "\tRank_3 BitBoard = 0x0000FF0000000000\n")
	fmt.Fprintf(w, "\tRank_4 BitBoard = 0x000000FF00000000\n")
	fmt.Fprintf(w, "\tRank_5 BitBoard = 0x00000000FF000000\n")
	fmt.Fprintf(w, "\tRank_6 BitBoard = 0x0000000000FF0000\n")
	fmt.Fprintf(w, "\tRank_7 BitBoard = 0x000000000000FF00\n")
	fmt.Fprintf(w, "\tRank_8 BitBoard = 0x00000000000000FF\n\n")

	fmt.Fprintf(w, "\tFile_Not_A BitBoard = ^File_A\n")
	fmt.Fprintf(w, "\tFile_Not_H BitBoard = ^File_H\n\n")

	fmt.Fprintf(w, "\tEmptyBoard BitBoard = 0\n")
	fmt.Fprintf(w, "\tFullBoard  BitBoard = 0xFFFFFFFFFFFFFFFF\n")
	fmt.Fprintf(w, ")\n")
}

// func genEnPassantNeighbours(w io.Writer) {
// 	fmt.Fprintf(w, "var enPassantNeighbours [Square(64)]BitBoard = [Square(64)]BitBoard{\n")
// 	for i := range 64 {
// 		if i < 23 || i > 40 {
// 			fmt.Fprintf(w, "\t0,\n")
// 		} else {
// 			mask := uint64(1 << i)
// 			_, f := sqaureToRankAndFile(i)

// 			if f != 0 {
// 				mask |= uint64(1<<i - 1)
// 			}

// 			if f != 7 {
// 				mask |= uint64(1<<i + 1)
// 			}
// 			fmt.Fprintf(w, "\t%d,\n", mask)
// 		}
// 	}
// 	fmt.Fprintf(w, "}\n")
// }

func generateSquares(w io.Writer) {
	fmt.Fprintf(w, "const (\n")
	for i := range 64 {
		r, f := sqaureToRankAndFile(i)
		if i == 0 {
			fmt.Fprintf(w, "\tSQ_%c%c Square = iota\n", 'A'+f, '1'+r)
		} else {
			fmt.Fprintf(w, "\tSQ_%c%c\n", 'A'+f, '1'+r)
		}
	}
	fmt.Fprintf(w, "\t SQ_NULL\n")
	fmt.Fprintf(w, ")\n")
}

func sqaureToRankAndFile(i int) (int, int) {
	return 7 - i/8, i % 8
}

func genMagicnumbers(w io.Writer) {

	fmt.Fprintf(w, "type Magic struct {\n")
	fmt.Fprintf(w, " \tAttacks []BitBoard\n")
	fmt.Fprintf(w, " \tMagic BitBoard\n")
	fmt.Fprintf(w, " \tMask BitBoard\n")
	fmt.Fprintf(w, " \tShift uint8\n")
	fmt.Fprintf(w, "}\n")

	rays := calculateRays()

	fmt.Fprintf(w, "var RookMagic [64]Magic = [64]Magic{")
	for sq := range 64 {
		rank, file := sqaureToRankAndFile(sq)
		mask := (rays[North][sq] | rays[South][sq] | rays[East][sq] | rays[West][sq])

		if rank != 0 {
			mask &= ^Rank_1
		}
		if rank != 7 {
			mask &= ^Rank_8
		}
		if file != 0 {
			mask &= ^File_A
		}
		if file != 7 {
			mask &= ^File_H
		}
		attackFunc := func(sq int, occupied uint64) uint64 {
			return rookAttacks(sq, occupied, rays)
		}
		rookBits := RookBits[sq]
		magic, attacks := findMagicNumber(sq, rookBits, mask, attackFunc)
		fmt.Fprintf(w, " \n{[]BitBoard{\n")
		for i := range attacks {
			fmt.Fprintf(w, "\t\t%d,\n", attacks[i])
		}
		fmt.Fprintf(w, "}, %d, %d, %d},\n", magic, mask, 64-rookBits)
	}
	fmt.Fprintf(w, "};\n")

	fmt.Fprintf(w, "var BishopMagic [64]Magic = [64]Magic{")
	for sq := range 64 {
		rank, file := sqaureToRankAndFile(sq)
		mask := (rays[NorthEast][sq] | rays[SouthEast][sq] | rays[SouthWest][sq] | rays[NorthWest][sq])

		if rank != 0 {
			mask &= ^Rank_1
		}
		if rank != 7 {
			mask &= ^Rank_8
		}
		if file != 0 {
			mask &= ^File_A
		}
		if file != 7 {
			mask &= ^File_H
		}

		attackFunc := func(sq int, occupied uint64) uint64 {
			return bishopAttacks(sq, occupied, rays)
		}
		bishopBits := BishopBits[sq]
		magic, attacks := findMagicNumber(sq, bishopBits, mask, attackFunc)
		fmt.Fprintf(w, " \n{[]BitBoard{\n")
		for i := range attacks {
			fmt.Fprintf(w, "\t\t%d,\n", attacks[i])
		}
		fmt.Fprintf(w, "}, %d, %d, %d},\n", magic, mask, 64-bishopBits)
	}
	fmt.Fprintf(w, "};\n")
}

func findMagicNumber(sq, m int, mask uint64, attackFunc func(int, uint64) uint64) (uint64, []uint64) {
	//mask := RookMask(sq)
	n := bits.OnesCount64(mask)

	blockers := make([]uint64, 1<<n)
	attacks := make([]uint64, 1<<n)
	used := make([]uint64, 4096)

	// generate all possible blocker sets
	for i := range 1 << n {
		blockers[i] = setBitsFromIndexInMask(i, n, mask)
		attacks[i] = attackFunc(sq, blockers[i])
		//fmt.Println(PrintBitboard(blockers[i]))
		//fmt.Println(PrintBitboard(attacks[i]))
	}

	for range 100_000_000 {
		magic := random()

		// to few bytes set
		if bits.OnesCount64((mask*magic)&0xFF00000000000000) < 6 {
			continue
		}

		// clean up used
		for i := range 4096 {
			used[i] = 0
		}

		var fail bool
		for i := range 1 << n {
			h := hash(blockers[i], magic, m)
			if used[h] == 0 {
				used[h] = attacks[i]
			} else if used[h] != attacks[i] {
				//collision detected
				fail = true
				break
			}
		}

		if !fail {
			return magic, used
		}
	}

	panic("Error generatic magic number")
}

func setBitsFromIndexInMask(index int, bitCount int, mask uint64) uint64 {
	var result uint64

	for i := range bitCount {
		lsb := bits.TrailingZeros64(mask)
		mask &= (mask - 1)

		if index&(1<<i) != 0 {
			result |= (1 << lsb)
		}
	}
	return result
}

func rookAttacks(sq int, occupied uint64, rays [8][64]uint64) uint64 {
	attacks := rays[North][sq]
	if intersect := rays[North][sq] & occupied; intersect != 0 {
		index := bits.LeadingZeros64(uint64(intersect))
		attacks &^= rays[North][63-index]
	}

	attacks |= rays[South][sq]
	if intersect := rays[South][sq] & occupied; intersect != 0 {
		index := bits.TrailingZeros64(uint64(intersect))
		attacks &^= rays[South][index]
	}

	attacks |= rays[East][sq]
	if intersect := rays[East][sq] & occupied; intersect != 0 {
		index := bits.TrailingZeros64(uint64(intersect))
		attacks &^= rays[East][index]
	}

	attacks |= rays[West][sq]
	if intersect := rays[West][sq] & occupied; intersect != 0 {
		index := bits.LeadingZeros64(uint64(intersect))
		attacks &^= rays[West][63-index]
	}
	return attacks
}

func bishopAttacks(sq int, occupied uint64, rays [8][64]uint64) uint64 {
	attacks := rays[NorthWest][sq]
	if intersect := rays[NorthWest][sq] & occupied; intersect != 0 {
		index := bits.LeadingZeros64(uint64(intersect))
		attacks &^= rays[NorthWest][63-index]
	}

	attacks |= rays[NorthEast][sq]
	if intersect := rays[NorthEast][sq] & occupied; intersect != 0 {
		index := bits.LeadingZeros64(uint64(intersect))
		attacks &^= rays[NorthEast][63-index]
	}

	attacks |= rays[SouthWest][sq]
	if intersect := rays[SouthWest][sq] & occupied; intersect != 0 {
		index := bits.TrailingZeros64(uint64(intersect))
		attacks &^= rays[SouthWest][index]
	}

	attacks |= rays[SouthEast][sq]
	if intersect := rays[SouthEast][sq] & occupied; intersect != 0 {
		index := bits.TrailingZeros64(uint64(intersect))
		attacks &^= rays[SouthEast][index]
	}
	return attacks
}

func hash(b, magic uint64, bits int) int {
	return int((b * magic) >> (64 - bits))
}

var RookBits = [64]int{
	12, 11, 11, 11, 11, 11, 11, 12, //a8-h8
	11, 10, 10, 10, 10, 10, 10, 11, //a7-h7
	11, 10, 10, 10, 10, 10, 10, 11, //a6-h6
	11, 10, 10, 10, 10, 10, 10, 11, //a5-h5
	11, 10, 10, 10, 10, 10, 10, 11, //a4-h4
	11, 10, 10, 10, 10, 10, 10, 11, //a3-h3
	11, 10, 10, 10, 10, 10, 10, 11, //a2-h2
	12, 11, 11, 11, 11, 11, 11, 12, //a1-h1
}

var BishopBits = [64]int{
	6, 5, 5, 5, 5, 5, 5, 6, //a8-h8
	5, 5, 5, 5, 5, 5, 5, 5, //a7-h7
	5, 5, 7, 7, 7, 7, 5, 5, //a6-h6
	5, 5, 7, 9, 9, 7, 5, 5, //a5-h5
	5, 5, 7, 9, 9, 7, 5, 5, //a4-h4
	5, 5, 7, 7, 7, 7, 5, 5, //a3-h3
	5, 5, 5, 5, 5, 5, 5, 5, //a2-h2
	6, 5, 5, 5, 5, 5, 5, 6, //a1-h1
}

func random() uint64 {
	return uint64(rand.Int63() & rand.Int63() & rand.Int63())
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// for deubgging
// func printBitboard(b uint64) string {
// 	builder := strings.Builder{}

// 	builder.WriteString("+---+---+---+---+---+---+---+---+\n")
// 	bit := uint64(1)
// 	for r := 7; r >= 0; r-- {
// 		builder.WriteString("|")
// 		for f := 0; f < 8; f++ {
// 			if b&bit != 0 {
// 				builder.WriteString(" X |")
// 			} else {
// 				builder.WriteString("   |")
// 			}
// 			bit <<= 1
// 		}
// 		builder.WriteString(fmt.Sprintf(" %d \n", r+1))
// 		builder.WriteString("+---+---+---+---+---+---+---+---+\n")
// 	}
// 	builder.WriteString("  a   b   c   d   e   f   g   h\n")
// 	return builder.String()
// }
